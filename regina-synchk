#!/usr/bin/env bash

clean () {
  rm -f ${stripped} ${numbered} ${log}
}

# Ensure single, non-empty string argument passed
[ $# -ne 1 -o -z "${1}" ] && { echo "Usage: ${0} <Rexx file>" ; exit 1 ; }

# Input file: Rexx script sans extension
source="${1##*/}" ; source="${source%.*}"

# Temporary files
stripped="${source}.stripped.rexx"
numbered="${source}.numbered.rexx"
log="${source}.log.txt"

# Strip all comments from script
sed -E 's/^\s*(.*)\/\*.*\*\/\s*(.*)/\1\2/g' "${source}.rexx" \
  | sed -E 's/^\s*(.*)\/\*.*\*\/\s*(.*)/\1\2/g' \
  | sed '/\/\*/,/*\//d;/^\s*$/d' > "${stripped}"

# Number the stripped script
cat -n "${stripped}" > "${numbered}"

# Execute script capturing error output
regina -tO "${stripped}" 2> "${log}" 1> /dev/null

# Remove any stack trace lines from the log file
sed -i '/\+\+\+/d' "${log}"

# Determine number of lines in the log file
nlines=$(wc -l "${log}" | cut -d' ' -f 1)

# Conditionaliy parse log output
case "${nlines}" in
  0) clean ; exit 0 ;;
  1) logdata=$(sed -E 's/^Error\s*([0-9]+)\s*.*,\s*line\s*([0-9]+)\:\s*(.*)/\2#\3/g' "${log}") ;;
  2) head -1 "${log}" | grep '\[.*\]' 2>&1 >/dev/null
     [ $? -eq 0 ] \
       && logdata=$(tail -1 "${log}" | sed -E 's/.*\[(.*) at line\s*([0-9]+).*/\2#\1/g') \
       || logdata=$(head -1 "${log}" | sed -E 's/^Error\s*([0-9]+)\s*.*,\s*line\s*([0-9]+)\:\s*(.*)/\2#\3/g') ;;
  *) printf 'Corrupted log file contents' ; clean ; exit 1 ;;
esac

lineno=$(echo "${logdata}" | cut -d'#' -f1)
msg=$(echo "${logdata}" | cut -d'#' -f2)
line=$(grep -E "^\s*${lineno}" "${numbered}" | tr '\t' ' ' | tr -s ' ')
linecode=$(echo "${line}" | cut -d' ' -f3-)

# Emit source code for context, and highlight source of problem
cat "${numbered}"
printf "\n${msg} on LINE: ${lineno} -> ${linecode}\n"

# Remove temporary files
clean

# Assume a syntax error occurred
exit 1
