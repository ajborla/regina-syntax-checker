#!/usr/bin/env bash

clean () {
  rm -f ${stripped} ${numbered} ${log}
}

# Ensure single, non-empty string argument passed
[ $# -ne 1 -o -z "${1}" ] && { echo "Usage: ${0} <Rexx file>" ; exit 1 ; }

# Input file: Rexx script sans extension
source="${1##*/}" ; source="${source%.*}"

# Temporary files
stripped="${source}.stripped.rexx"
numbered="${source}.numbered.rexx"
log="${source}.log.txt"

# Strip all comments from script
sed -E 's/^\s*(.*)\/\*.*\*\/\s*(.*)/\1\2/g' "${source}.rexx" \
  | sed -E 's/^\s*(.*)\/\*.*\*\/\s*(.*)/\1\2/g' \
  | sed '/\/\*/,/*\//d;/^\s*$/d' > "${stripped}"

# Number the stripped script
cat -n "${stripped}" > "${numbered}"

# Execute script capturing error output
regina -tO "${stripped}" 2> "${log}" 1> /dev/null

# Remove any stack trace lines from the log file
sed -i '/\+\+\+/d' "${log}"

# Determine number of lines in the log file
nlines=$(wc -l "${log}" | cut -d' ' -f 1)

# Handle special case of 'command not found' /
#  'not recognized as an internal or external command'
chkline=$(head -1 "${log}") ; echo "${chkline}" | grep 'command not found' 2>&1 >/dev/null
if [ $? -eq 0 ] ; then
  cmdname=$(echo "${chkline}" | cut -d' ' -f2 | cut -d':' -f1)
else
  echo "${chkline}" | grep 'external command' 2>&1 >/dev/null
  [ $? -eq 0 ] && cmdname=$(echo "${chkline}" | cut -d' ' -f1 | tr -d "'")
fi

if [ -z "${cmdname}" ] ; then
  # Conditionaliy parse log output
  case "${nlines}" in
    0) clean ; exit 0 ;;
    1) logdata=$(sed -E 's/^Error\s*([0-9]+)\s*.*,\s*line\s*([0-9]+)\:\s*(.*)/\2#\3/g' "${log}") ;;
    2) echo "${chkline}" | grep '\[.*\]' 2>&1 >/dev/null
       [ $? -eq 0 ] \
         && logdata=$(tail -1 "${log}" | sed -E 's/.*\[(.*) at line\s*([0-9]+).*/\2#\1/g') \
         || logdata=$(echo "${chkline}" | sed -E 's/^Error\s*([0-9]+)\s*.*,\s*line\s*([0-9]+)\:\s*(.*)/\2#\3/g') ;;
    *) printf 'Corrupted log file contents' ; clean ; exit 1 ;;
  esac
  lineno=$(echo "${logdata}" | cut -d'#' -f1)
  msg=$(echo "${logdata}" | cut -d'#' -f2)
  line=$(grep -E "^\s*${lineno}" "${numbered}" | tr '\t' ' ' | tr -s ' ')
else
  line=$(grep -i "${cmdname}" "${numbered}" | tr '\t' ' ' | tr -s ' ')
  lineno=$(echo "${line}" | cut -d' ' -f2)
  msg='Procedure or function name is probably misspelled'
fi

linecode=$(echo "${line}" | cut -d' ' -f3-)

# Emit source code for context, and highlight source of problem
cat "${numbered}"
printf "\n${msg} on LINE: ${lineno} -> ${linecode}\n"

# Remove temporary files
clean

# Assume a syntax error occurred
exit 1
